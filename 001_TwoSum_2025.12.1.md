

Two Sum:

The conventional approach is to use a brute-force nested double For loop, which has a time complexity of O(n²), while the optimal solution employs a hash table.

(两数之和：

常规想法暴力双For嵌套，时间复杂度O(n²),最优解是哈希表。）

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); ++i) {
            auto res = hash.find(target - nums[i]);
            if (res != hash.end()) {
                return {res->second, i};
            }
            hash[nums[i]] = i;
        }
        return {-1,-1};
    }
};

```



Two Sum II:

At first, seeing that the array is sorted, I thought of the two-pointer algorithm and binary search.

Then, following the template, I used a for loop to search.



(两数之和II：

最开始，看到有序就想到了双指针算法二分查找。

然后根据模板，使用for循环查找。)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int len = numbers.size();
        for(int i = 0; i < len ; ++i)
        {
            int res = target - numbers[i];

            int l = i + 1,r = len - 1;
            while(l < r)
            {
                int mid = (l + r) >> 1;
                if(numbers[mid] >= res)
                    r = mid;
                else
                    l = mid + 1;
            }
        if(numbers[l] == res)
            return {i + 1,l + 1};
        }
    return {};
    }
};
```



Then I found that my approach took 4 milliseconds, while the optimal solution only took 1 millisecond. I reflected on the shortcomings of the template and then revised the code. A more efficient handling method should be as follows:

Instead of iterating and calculating with `mid`, a better approach is to compare the "left boundary", "right boundary" with `mid`, then increment or decrement the pointers to narrow down the range until the answer is found. After that, use a `vector` to store the answer and output it directly.



(然后发现我的做法花了4ms。而最优解是1ms。思考模板的不足之处，然后修改代码，更高效的处理方法应该是：

比起使用mid去遍历计算，更好的方法应该是使用“左边界“、”右边界”与“mid”比较，然后指针增加或减少来缩小范围直至得到答案，然后vector去存储答案，并且直接输出它。)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int len = numbers.size();
        vector<int> res;
        int l = 0,r = len - 1;
        while(l < r)
        {
            if(numbers[l] + numbers[r] == target){
                    res.push_back(l + 1);
                    res.push_back(r + 1);
                    return res;
            }
            while(numbers[l] + numbers[r] < target)l++;
            while(numbers[l] + numbers[r] > target)r--;    
        }
          return {};
    }
};
```

